import{_ as E,C as a,c as b,o,j as r,G as n,a3 as e,b as c,a as p,w as l,a9 as i}from"./chunks/framework.C_JJgOUQ.js";const S=JSON.parse('{"title":"Implementing maxSkew: How to Safely Update Nodes at Scale","description":"Lessons learned from implementing maxSkew to safely control large-scale rolling updates in a Kubernetes Operator.","frontmatter":{"title":"Implementing maxSkew: How to Safely Update Nodes at Scale","date":"2025-12-18T00:00:00.000Z","author":"Tim Kang","github":"selenehyun","description":"Lessons learned from implementing maxSkew to safely control large-scale rolling updates in a Kubernetes Operator.","tags":["Kubernetes","Operator","Rolling Update","maxSkew"],"sidebar":false,"editLink":false,"prev":false,"next":false},"headers":[],"relativePath":"blog/maxskew-implementation-lessons.md","filePath":"blog/maxskew-implementation-lessons.md","lastUpdated":1766025659000}'),m={name:"blog/maxskew-implementation-lessons.md"};function h(g,s,F,f,v,C){const u=a("BlogPostMeta"),d=a("BlastRadiusAnimation"),t=a("Mermaid"),y=a("BlogPostFooter");return o(),b("div",null,[s[2]||(s[2]=r("h1",{id:"implementing-maxskew-how-to-safely-update-nodes-at-scale",tabindex:"-1"},[p("Implementing maxSkew: How to Safely Update Nodes at Scale "),r("a",{class:"header-anchor",href:"#implementing-maxskew-how-to-safely-update-nodes-at-scale","aria-label":'Permalink to "Implementing maxSkew: How to Safely Update Nodes at Scale"'},"​")],-1)),n(u),s[3]||(s[3]=e(`<p>One of the most challenging aspects of developing a Kubernetes Operator was handling large-scale rolling updates. What happens when modifying a single template triggers updates across hundreds of nodes simultaneously? This post shares the lessons learned from implementing Lynq Operator&#39;s <code>maxSkew</code> feature.</p><h2 id="the-problem-blast-radius" tabindex="-1">The Problem: Blast Radius <a class="header-anchor" href="#the-problem-blast-radius" aria-label="Permalink to &quot;The Problem: Blast Radius&quot;">​</a></h2><p>In the RecordOps pattern, a single LynqForm (template) applies to hundreds or thousands of LynqNodes. When you modify the template, all node Deployments must be updated.</p><div class="language-yaml line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;"># What if this single template applies to hundreds of nodes?</span></span>
<span class="line"><span style="color:#85E89D;">apiVersion</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">lynq.sh/v1</span></span>
<span class="line"><span style="color:#85E89D;">kind</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">LynqForm</span></span>
<span class="line"><span style="color:#85E89D;">spec</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#85E89D;">  deployments</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">    - </span><span style="color:#85E89D;">id</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">app</span></span>
<span class="line"><span style="color:#85E89D;">      spec</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#85E89D;">        template</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#85E89D;">          spec</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#85E89D;">            containers</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">              - </span><span style="color:#85E89D;">image</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">app:v2</span><span style="color:#6A737D;">  # Changed from v1 to v2</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>What if <code>app:v2</code> has a bug? All Pods would simultaneously enter CrashLoopBackOff. The entire cluster would be paralyzed.</p><p>Even without bugs, updating all nodes at once creates serious problems:</p><ul><li><strong>Image pull storm</strong>: Hundreds of nodes pulling the same container image simultaneously saturates network bandwidth and can overload the container registry</li><li><strong>Resource contention</strong>: Old and new Pods running concurrently during rollout doubles CPU and memory consumption, potentially triggering OOM kills</li><li><strong>API server overload</strong>: Massive concurrent updates flood the Kubernetes API server with requests, slowing down the entire cluster</li><li><strong>Cascading failures</strong>: If new Pods fail readiness probes, traffic still routes to terminating old Pods, causing request failures across all services</li></ul><p>And if there&#39;s a bug in the new version, you have no time to react. By the time you notice something is wrong, every single node is already affected.</p>`,8)),n(d),s[4]||(s[4]=e(`<h2 id="the-solution-maxskew" tabindex="-1">The Solution: maxSkew <a class="header-anchor" href="#the-solution-maxskew" aria-label="Permalink to &quot;The Solution: maxSkew&quot;">​</a></h2><p>Just as Kubernetes Deployments use <code>maxSurge</code> and <code>maxUnavailable</code> to control rolling updates, Lynq uses <code>maxSkew</code> to limit the number of nodes updating concurrently.</p><div class="language-yaml line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#85E89D;">apiVersion</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">lynq.sh/v1</span></span>
<span class="line"><span style="color:#85E89D;">kind</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">LynqHub</span></span>
<span class="line"><span style="color:#85E89D;">spec</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#85E89D;">  rollout</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#85E89D;">    maxSkew</span><span style="color:#E1E4E8;">: </span><span style="color:#79B8FF;">10</span><span style="color:#6A737D;">  # Update at most 10 nodes simultaneously</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>The implementation logic is simple: only start the next node update when the current updating node count is below maxSkew. This is essentially a sliding window approach.</p><div class="tip custom-block"><p class="custom-block-title">Feedback Welcome</p><p>Currently, Lynq only supports this sliding window rollout strategy. Whether we need other strategies (like canary or blue-green) is still an open question. If you have thoughts or use cases that would benefit from different rollout approaches, please share them on <a href="https://github.com/k8s-lynq/lynq/issues" target="_blank" rel="noreferrer">GitHub Issues</a>.</p></div><h2 id="first-implementation-status-based-counting" tabindex="-1">First Implementation: Status-Based Counting <a class="header-anchor" href="#first-implementation-status-based-counting" aria-label="Permalink to &quot;First Implementation: Status-Based Counting&quot;">​</a></h2><p>The most intuitive approach is to check each LynqNode&#39;s Status.</p><div class="language-go line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">r </span><span style="color:#F97583;">*</span><span style="color:#B392F0;">LynqHubReconciler</span><span style="color:#E1E4E8;">) </span><span style="color:#B392F0;">countUpdatingNodes</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">nodes</span><span style="color:#E1E4E8;"> []</span><span style="color:#B392F0;">LynqNode</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    count </span><span style="color:#F97583;">:=</span><span style="color:#79B8FF;"> 0</span></span>
<span class="line"><span style="color:#F97583;">    for</span><span style="color:#E1E4E8;"> _, node </span><span style="color:#F97583;">:=</span><span style="color:#F97583;"> range</span><span style="color:#E1E4E8;"> nodes {</span></span>
<span class="line"><span style="color:#F97583;">        if</span><span style="color:#F97583;"> !</span><span style="color:#E1E4E8;">meta.</span><span style="color:#B392F0;">IsStatusConditionTrue</span><span style="color:#E1E4E8;">(node.Status.Conditions, </span><span style="color:#9ECBFF;">&quot;Ready&quot;</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            count</span><span style="color:#F97583;">++</span><span style="color:#6A737D;">  // Not Ready means updating</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#F97583;">    return</span><span style="color:#E1E4E8;"> count</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>But this implementation had a critical flaw.</p><h2 id="discovering-the-problem-statusmanager-s-batch-processing" tabindex="-1">Discovering the Problem: StatusManager&#39;s Batch Processing <a class="header-anchor" href="#discovering-the-problem-statusmanager-s-batch-processing" aria-label="Permalink to &quot;Discovering the Problem: StatusManager&#39;s Batch Processing&quot;">​</a></h2><p>During testing, we noticed strange behavior. Even with <code>maxSkew: 1</code>, occasionally 2-3 nodes would update simultaneously.</p><p>The cause was Lynq StatusManager&#39;s batch processing approach:</p>`,12)),(o(),c(i,null,{default:l(()=>[n(t,{id:"mermaid-82",class:"mermaid my-class",graph:"sequenceDiagram%0A%20%20%20%20participant%20Node1%20as%20Node1%20Controller%0A%20%20%20%20participant%20SM%20as%20StatusManager%0A%20%20%20%20participant%20Hub%20as%20Hub%20Controller%0A%0A%20%20%20%20Node1-%3E%3ENode1%3A%20Start%20Reconcile%0A%20%20%20%20Node1-%3E%3ENode1%3A%20Apply%20Resources%0A%20%20%20%20Node1-%3E%3ESM%3A%20Request%20Status%20Update%20(Ready%3DFalse)%0A%20%20%20%20Note%20over%20SM%3A%20Waiting%20for%20batch%20(up%20to%201%20second)%0A%20%20%20%20Hub-%3E%3ESM%3A%20Call%20countUpdatingNodes%0A%20%20%20%20SM--%3E%3EHub%3A%20Node1%20Status%3A%20Ready%3DTrue%20(stale%20value!)%0A%20%20%20%20Note%20over%20Hub%3A%20count%20%3D%200%20%E2%86%92%20Start%20Node2%20update!%0A%20%20%20%20SM-%3E%3ESM%3A%20Flush%20batch%0A%20%20%20%20Note%20over%20SM%3A%20Ready%3DFalse%20finally%20reflected%0A"})]),fallback:l(()=>[...s[0]||(s[0]=[p(" Loading... ",-1)])]),_:1})),s[5]||(s[5]=e(`<p>StatusManager batches Status updates for performance. When Node1&#39;s Reconcile starts and applies resources, but the Status hasn&#39;t been updated to <code>Ready=False</code> yet, the Hub controller calling <code>countUpdatingNodes</code> still sees Node1 as Ready.</p><h2 id="introducing-safety-margin" tabindex="-1">Introducing Safety Margin <a class="header-anchor" href="#introducing-safety-margin" aria-label="Permalink to &quot;Introducing Safety Margin&quot;">​</a></h2><p>To solve this race condition, we introduced a time-based Safety Margin. We record the update start time in an Annotation, and regardless of Status, consider the node as &quot;updating&quot; for a certain period.</p><div class="language-go line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> safetyMargin</span><span style="color:#F97583;"> =</span><span style="color:#79B8FF;"> 2</span><span style="color:#F97583;"> *</span><span style="color:#E1E4E8;"> time.Second</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">r </span><span style="color:#F97583;">*</span><span style="color:#B392F0;">LynqHubReconciler</span><span style="color:#E1E4E8;">) </span><span style="color:#B392F0;">countUpdatingNodes</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">nodes</span><span style="color:#E1E4E8;"> []</span><span style="color:#B392F0;">LynqNode</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    count </span><span style="color:#F97583;">:=</span><span style="color:#79B8FF;"> 0</span></span>
<span class="line"><span style="color:#F97583;">    for</span><span style="color:#E1E4E8;"> _, node </span><span style="color:#F97583;">:=</span><span style="color:#F97583;"> range</span><span style="color:#E1E4E8;"> nodes {</span></span>
<span class="line"><span style="color:#6A737D;">        // Safety Margin: Handle async Status update delay</span></span>
<span class="line"><span style="color:#E1E4E8;">        startTime </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> node.Annotations[</span><span style="color:#9ECBFF;">&quot;rollout-update-start-time&quot;</span><span style="color:#E1E4E8;">]</span></span>
<span class="line"><span style="color:#F97583;">        if</span><span style="color:#E1E4E8;"> time.</span><span style="color:#B392F0;">Since</span><span style="color:#E1E4E8;">(startTime) </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> safetyMargin {</span></span>
<span class="line"><span style="color:#E1E4E8;">            count</span><span style="color:#F97583;">++</span></span>
<span class="line"><span style="color:#F97583;">            continue</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">        // Check Status</span></span>
<span class="line"><span style="color:#F97583;">        if</span><span style="color:#F97583;"> !</span><span style="color:#E1E4E8;">meta.</span><span style="color:#B392F0;">IsStatusConditionTrue</span><span style="color:#E1E4E8;">(node.Status.Conditions, </span><span style="color:#9ECBFF;">&quot;Ready&quot;</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            count</span><span style="color:#F97583;">++</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#F97583;">    return</span><span style="color:#E1E4E8;"> count</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>We set it to 2 seconds considering StatusManager&#39;s batch flush interval (up to 1 second) plus buffer. Now when a node starts updating, it&#39;s counted as updating for at least 2 seconds.</p><h2 id="second-problem-the-definition-of-ready" tabindex="-1">Second Problem: The Definition of &quot;Ready&quot; <a class="header-anchor" href="#second-problem-the-definition-of-ready" aria-label="Permalink to &quot;Second Problem: The Definition of &quot;Ready&quot;&quot;">​</a></h2><p>Safety Margin solved the race condition, but E2E tests revealed another issue.</p><div class="language-go line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#B392F0;">It</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;should wait for Pod readiness before updating next node&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">func</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#6A737D;">    // Deployment configured with initialDelaySeconds: 15</span></span>
<span class="line"><span style="color:#6A737D;">    // maxSkew: 1</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">    // Monitor after template update</span></span>
<span class="line"><span style="color:#6A737D;">    // Expected: Wait for Pod Ready before updating next node</span></span>
<span class="line"><span style="color:#6A737D;">    // Actual: Next node update starts as soon as LynqNode Status becomes Ready=True!</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>LynqNode&#39;s <code>Ready</code> condition indicates whether the resource Apply succeeded. But applying a Deployment doesn&#39;t mean the Pod is Ready.</p>`,9)),(o(),c(i,null,{default:l(()=>[n(t,{id:"mermaid-106",class:"mermaid my-class",graph:"sequenceDiagram%0A%20%20%20%20participant%20Node1%20as%20Node1%20Controller%0A%20%20%20%20participant%20K8s%20as%20Kubernetes%0A%20%20%20%20participant%20Hub%20as%20Hub%20Controller%0A%0A%20%20%20%20Node1-%3E%3EK8s%3A%20Apply%20Deployment%0A%20%20%20%20K8s--%3E%3ENode1%3A%20Apply%20Success%0A%20%20%20%20Node1-%3E%3ENode1%3A%20LynqNode%20Ready%3DTrue%0A%20%20%20%20Note%20over%20K8s%3A%20Pod%3A%20Waiting%20for%20initialDelaySeconds...%0A%20%20%20%20Hub-%3E%3ENode1%3A%20Check%20Node1%20Ready%0A%20%20%20%20Node1--%3E%3EHub%3A%20Ready%3DTrue%0A%20%20%20%20Note%20over%20Hub%3A%20Start%20Node2%20update!%0A%20%20%20%20Note%20over%20K8s%3A%20(15%20seconds%20later)%20Pod%20Ready%0A%20%20%20%20Note%20over%20Hub%3A%20At%20this%20point%20Pod%20is%20still%20not%20Ready!%0A"})]),fallback:l(()=>[...s[1]||(s[1]=[p(" Loading... ",-1)])]),_:1})),s[6]||(s[6]=e(`<p>The purpose of <code>maxSkew</code> is &quot;limiting the number of nodes updating simultaneously.&quot; But our implementation was &quot;limiting the number of nodes applying resources simultaneously.&quot; If the next node update starts before the Pod is actually Ready, the blast radius limitation becomes meaningless.</p><h2 id="solution-check-actual-resource-state" tabindex="-1">Solution: Check Actual Resource State <a class="header-anchor" href="#solution-check-actual-resource-state" aria-label="Permalink to &quot;Solution: Check Actual Resource State&quot;">​</a></h2><p>The solution is to directly check the actual Kubernetes resource state, not the LynqNode Status.</p><div class="language-go line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">r </span><span style="color:#F97583;">*</span><span style="color:#B392F0;">LynqHubReconciler</span><span style="color:#E1E4E8;">) </span><span style="color:#B392F0;">isNodeResourcesActuallyReady</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">ctx</span><span style="color:#B392F0;"> context</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">Context</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">node</span><span style="color:#F97583;"> *</span><span style="color:#B392F0;">LynqNode</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">bool</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">    for</span><span style="color:#E1E4E8;"> _, resource </span><span style="color:#F97583;">:=</span><span style="color:#F97583;"> range</span><span style="color:#E1E4E8;"> node.Status.AppliedResources {</span></span>
<span class="line"><span style="color:#F97583;">        switch</span><span style="color:#E1E4E8;"> resource.Kind {</span></span>
<span class="line"><span style="color:#F97583;">        case</span><span style="color:#9ECBFF;"> &quot;Deployment&quot;</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#F97583;">            var</span><span style="color:#E1E4E8;"> deploy </span><span style="color:#B392F0;">appsv1</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">Deployment</span></span>
<span class="line"><span style="color:#E1E4E8;">            r.Client.</span><span style="color:#B392F0;">Get</span><span style="color:#E1E4E8;">(ctx, resource.</span><span style="color:#B392F0;">NamespacedName</span><span style="color:#E1E4E8;">(), </span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;">deploy)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">            // Key: Check Progressing condition</span></span>
<span class="line"><span style="color:#E1E4E8;">            progressing </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> meta.</span><span style="color:#B392F0;">FindStatusCondition</span><span style="color:#E1E4E8;">(deploy.Status.Conditions, </span><span style="color:#9ECBFF;">&quot;Progressing&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">            if</span><span style="color:#E1E4E8;"> progressing </span><span style="color:#F97583;">==</span><span style="color:#79B8FF;"> nil</span><span style="color:#F97583;"> ||</span><span style="color:#E1E4E8;"> progressing.Reason </span><span style="color:#F97583;">!=</span><span style="color:#9ECBFF;"> &quot;NewReplicaSetAvailable&quot;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">                return</span><span style="color:#79B8FF;"> false</span><span style="color:#6A737D;">  // Rollout still in progress</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">            // Check Available replicas</span></span>
<span class="line"><span style="color:#F97583;">            if</span><span style="color:#E1E4E8;"> deploy.Status.AvailableReplicas </span><span style="color:#F97583;">&lt;</span><span style="color:#F97583;"> *</span><span style="color:#E1E4E8;">deploy.Spec.Replicas {</span></span>
<span class="line"><span style="color:#F97583;">                return</span><span style="color:#79B8FF;"> false</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#F97583;">    return</span><span style="color:#79B8FF;"> true</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>The key insight is the Deployment&#39;s Progressing condition:</p><table tabindex="0"><thead><tr><th>Reason</th><th>Meaning</th></tr></thead><tbody><tr><td><code>ReplicaSetUpdated</code></td><td>Rollout in progress</td></tr><tr><td><code>NewReplicaSetAvailable</code></td><td>Rollout complete</td></tr><tr><td><code>ProgressDeadlineExceeded</code></td><td>Timeout (failed)</td></tr></tbody></table><p>Checking only <code>AvailableReplicas</code> isn&#39;t enough. Pods from the previous ReplicaSet might still be Running. Only when <code>Progressing.Reason == &quot;NewReplicaSetAvailable&quot;</code> is the new version fully deployed.</p><h2 id="final-implementation" tabindex="-1">Final Implementation <a class="header-anchor" href="#final-implementation" aria-label="Permalink to &quot;Final Implementation&quot;">​</a></h2><p>The final implementation combines three conditions:</p><div class="language-go line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">r </span><span style="color:#F97583;">*</span><span style="color:#B392F0;">LynqHubReconciler</span><span style="color:#E1E4E8;">) </span><span style="color:#B392F0;">countUpdatingNodes</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">ctx</span><span style="color:#B392F0;"> context</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">Context</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">nodes</span><span style="color:#E1E4E8;"> []</span><span style="color:#B392F0;">LynqNode</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    count </span><span style="color:#F97583;">:=</span><span style="color:#79B8FF;"> 0</span></span>
<span class="line"><span style="color:#F97583;">    for</span><span style="color:#E1E4E8;"> _, node </span><span style="color:#F97583;">:=</span><span style="color:#F97583;"> range</span><span style="color:#E1E4E8;"> nodes {</span></span>
<span class="line"><span style="color:#6A737D;">        // 1. Safety Margin (Handle async Status updates)</span></span>
<span class="line"><span style="color:#F97583;">        if</span><span style="color:#E1E4E8;"> time.</span><span style="color:#B392F0;">Since</span><span style="color:#E1E4E8;">(node.</span><span style="color:#B392F0;">UpdateStartTime</span><span style="color:#E1E4E8;">()) </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> safetyMargin {</span></span>
<span class="line"><span style="color:#E1E4E8;">            count</span><span style="color:#F97583;">++</span></span>
<span class="line"><span style="color:#F97583;">            continue</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">        // 2. Check LynqNode Status</span></span>
<span class="line"><span style="color:#F97583;">        if</span><span style="color:#F97583;"> !</span><span style="color:#E1E4E8;">meta.</span><span style="color:#B392F0;">IsStatusConditionTrue</span><span style="color:#E1E4E8;">(node.Status.Conditions, </span><span style="color:#9ECBFF;">&quot;Ready&quot;</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            count</span><span style="color:#F97583;">++</span></span>
<span class="line"><span style="color:#F97583;">            continue</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">        // 3. Check actual resource state (Key!)</span></span>
<span class="line"><span style="color:#F97583;">        if</span><span style="color:#F97583;"> !</span><span style="color:#E1E4E8;">r.</span><span style="color:#B392F0;">isNodeResourcesActuallyReady</span><span style="color:#E1E4E8;">(ctx, </span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;">node) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            count</span><span style="color:#F97583;">++</span></span>
<span class="line"><span style="color:#F97583;">            continue</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#F97583;">    return</span><span style="color:#E1E4E8;"> count</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><h2 id="lessons-learned" tabindex="-1">Lessons Learned <a class="header-anchor" href="#lessons-learned" aria-label="Permalink to &quot;Lessons Learned&quot;">​</a></h2><h3 id="_1-recognize-asynchronous-characteristics-in-your-implementation" tabindex="-1">1. Recognize Asynchronous Characteristics in Your Implementation <a class="header-anchor" href="#_1-recognize-asynchronous-characteristics-in-your-implementation" aria-label="Permalink to &quot;1. Recognize Asynchronous Characteristics in Your Implementation&quot;">​</a></h3><p>This problem wasn&#39;t a Kubernetes characteristic but a Lynq StatusManager design choice. The race condition arose from batching Status updates for performance. If Status were updated synchronously, this problem wouldn&#39;t exist. The time-based Safety Margin is a workaround, not a perfect solution. We need to keep exploring better approaches.</p><h3 id="_2-define-ready-clearly" tabindex="-1">2. Define &quot;Ready&quot; Clearly <a class="header-anchor" href="#_2-define-ready-clearly" aria-label="Permalink to &quot;2. Define &quot;Ready&quot; Clearly&quot;">​</a></h3><p>LynqNode being Ready and Pod being Ready are different things. Clearly define what &quot;Ready&quot; means at each layer, and check the appropriate layer&#39;s state for your purpose.</p><h3 id="_3-find-the-source-of-truth" tabindex="-1">3. Find the Source of Truth <a class="header-anchor" href="#_3-find-the-source-of-truth" aria-label="Permalink to &quot;3. Find the Source of Truth&quot;">​</a></h3><p>Sometimes you need to directly query the actual resources, not cached Status, events, or inferences. There&#39;s a performance cost, but it&#39;s essential for decisions where accuracy matters.</p><h3 id="_4-understand-deployment-status-conditions" tabindex="-1">4. Understand Deployment Status Conditions <a class="header-anchor" href="#_4-understand-deployment-status-conditions" aria-label="Permalink to &quot;4. Understand Deployment Status Conditions&quot;">​</a></h3><p>To accurately determine rollout completion, check the <code>Progressing</code> condition:</p><div class="language-go line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// Rollout completion check</span></span>
<span class="line"><span style="color:#E1E4E8;">conditions.Progressing.Reason </span><span style="color:#F97583;">==</span><span style="color:#9ECBFF;"> &quot;NewReplicaSetAvailable&quot;</span><span style="color:#E1E4E8;"> AND</span></span>
<span class="line"><span style="color:#E1E4E8;">status.AvailableReplicas </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> spec.Replicas AND</span></span>
<span class="line"><span style="color:#E1E4E8;">status.UpdatedReplicas </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> spec.Replicas</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="_5-e2e-tests-are-essential" tabindex="-1">5. E2E Tests Are Essential <a class="header-anchor" href="#_5-e2e-tests-are-essential" aria-label="Permalink to &quot;5. E2E Tests Are Essential&quot;">​</a></h3><p>Asynchronous behavior, timing issues, and multi-component interactions are hard to catch with unit tests. Some problems only surface when testing actual rollouts in a real Kubernetes cluster.</p><h2 id="remaining-challenge-custom-resource-ready-detection" tabindex="-1">Remaining Challenge: Custom Resource Ready Detection <a class="header-anchor" href="#remaining-challenge-custom-resource-ready-detection" aria-label="Permalink to &quot;Remaining Challenge: Custom Resource Ready Detection&quot;">​</a></h2><p>Deployment, StatefulSet, and DaemonSet have standardized status fields provided by Kubernetes. But what about Custom Resources (CRs)?</p><div class="language-yaml line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#85E89D;">apiVersion</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">lynq.sh/v1</span></span>
<span class="line"><span style="color:#85E89D;">kind</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">LynqForm</span></span>
<span class="line"><span style="color:#85E89D;">spec</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#85E89D;">  manifests</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">    - </span><span style="color:#85E89D;">id</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">mysql-cluster</span></span>
<span class="line"><span style="color:#85E89D;">      spec</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#85E89D;">        apiVersion</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">mysql.oracle.com/v2</span></span>
<span class="line"><span style="color:#85E89D;">        kind</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">InnoDBCluster</span></span>
<span class="line"><span style="color:#6A737D;">        # ...</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>Countless CRs exist: MySQL Operator&#39;s <code>InnoDBCluster</code>, Prometheus Operator&#39;s <code>ServiceMonitor</code>, Cert-Manager&#39;s <code>Certificate</code>, etc. The problem is there&#39;s no standardized Ready state for them. Each Operator provider decides their own status representation, making universal Ready detection impossible.</p><h3 id="problem-non-standardized-status-representation" tabindex="-1">Problem: Non-Standardized Status Representation <a class="header-anchor" href="#problem-non-standardized-status-representation" aria-label="Permalink to &quot;Problem: Non-Standardized Status Representation&quot;">​</a></h3><p>CR status representation varies by Operator:</p><div class="language-yaml line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;"># MySQL Operator - uses status.cluster.status</span></span>
<span class="line"><span style="color:#85E89D;">status</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#85E89D;">  cluster</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#85E89D;">    status</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">ONLINE</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;"># Cert-Manager - uses conditions but different type</span></span>
<span class="line"><span style="color:#85E89D;">status</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#85E89D;">  conditions</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">    - </span><span style="color:#85E89D;">type</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">Ready</span></span>
<span class="line"><span style="color:#85E89D;">      status</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">&quot;True&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;"># Some Operators - no status at all</span></span>
<span class="line"><span style="color:#85E89D;">status</span><span style="color:#E1E4E8;">: {}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>Currently, Lynq treats CRs as &quot;Apply success = Ready&quot;. But this is risky. Applying an <code>InnoDBCluster</code> doesn&#39;t mean the MySQL cluster is actually Ready. Cluster setup can take several minutes.</p><h3 id="potential-solutions" tabindex="-1">Potential Solutions <a class="header-anchor" href="#potential-solutions" aria-label="Permalink to &quot;Potential Solutions&quot;">​</a></h3><h4 id="_1-minimum-delay" tabindex="-1">1. Minimum Delay <a class="header-anchor" href="#_1-minimum-delay" aria-label="Permalink to &quot;1. Minimum Delay&quot;">​</a></h4><p>The simplest approach is to enforce a minimum delay between node updates:</p><div class="language-yaml line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#85E89D;">apiVersion</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">lynq.sh/v1</span></span>
<span class="line"><span style="color:#85E89D;">kind</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">LynqHub</span></span>
<span class="line"><span style="color:#85E89D;">spec</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#85E89D;">  rollout</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#85E89D;">    maxSkew</span><span style="color:#E1E4E8;">: </span><span style="color:#79B8FF;">10</span></span>
<span class="line"><span style="color:#85E89D;">    minDelay</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">60s</span><span style="color:#6A737D;">  # Wait at least 60 seconds before next node update</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>Even without knowing the exact Ready state, most resources stabilize after sufficient time. The advantage is simple implementation and applicability to all resource types.</p><p>The downside is clear: even resources that only need 10 seconds must wait 60 seconds. It&#39;s a trade-off between efficiency and safety.</p><h4 id="_2-custom-ready-probe" tabindex="-1">2. Custom Ready Probe <a class="header-anchor" href="#_2-custom-ready-probe" aria-label="Permalink to &quot;2. Custom Ready Probe&quot;">​</a></h4><p>Let users define their own Ready detection logic:</p><div class="language-yaml line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#85E89D;">apiVersion</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">lynq.sh/v1</span></span>
<span class="line"><span style="color:#85E89D;">kind</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">LynqForm</span></span>
<span class="line"><span style="color:#85E89D;">spec</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#85E89D;">  manifests</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">    - </span><span style="color:#85E89D;">id</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">mysql-cluster</span></span>
<span class="line"><span style="color:#85E89D;">      spec</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#85E89D;">        apiVersion</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">mysql.oracle.com/v2</span></span>
<span class="line"><span style="color:#85E89D;">        kind</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">InnoDBCluster</span></span>
<span class="line"><span style="color:#85E89D;">      readyProbe</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#85E89D;">        jsonPath</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">&quot;.status.cluster.status&quot;</span></span>
<span class="line"><span style="color:#85E89D;">        expectedValue</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">&quot;ONLINE&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>Flexible, but users need to know each CR&#39;s status structure.</p><h4 id="_3-leverage-conditions-convention" tabindex="-1">3. Leverage Conditions Convention <a class="header-anchor" href="#_3-leverage-conditions-convention" aria-label="Permalink to &quot;3. Leverage Conditions Convention&quot;">​</a></h4><p>Many CRs follow Kubernetes&#39; <a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties" target="_blank" rel="noreferrer">Conditions convention</a>:</p><div class="language-go line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// Common logic to find type=Ready, status=True</span></span>
<span class="line"><span style="color:#F97583;">func</span><span style="color:#B392F0;"> isCustomResourceReady</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">cr</span><span style="color:#F97583;"> *</span><span style="color:#B392F0;">unstructured</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">Unstructured</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">bool</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    conditions, found, _ </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> unstructured.</span><span style="color:#B392F0;">NestedSlice</span><span style="color:#E1E4E8;">(cr.Object, </span><span style="color:#9ECBFF;">&quot;status&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&quot;conditions&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">    if</span><span style="color:#F97583;"> !</span><span style="color:#E1E4E8;">found {</span></span>
<span class="line"><span style="color:#F97583;">        return</span><span style="color:#79B8FF;"> false</span><span style="color:#6A737D;">  // Unknown without conditions</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#F97583;">    for</span><span style="color:#E1E4E8;"> _, c </span><span style="color:#F97583;">:=</span><span style="color:#F97583;"> range</span><span style="color:#E1E4E8;"> conditions {</span></span>
<span class="line"><span style="color:#F97583;">        if</span><span style="color:#E1E4E8;"> c[</span><span style="color:#9ECBFF;">&quot;type&quot;</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">==</span><span style="color:#9ECBFF;"> &quot;Ready&quot;</span><span style="color:#F97583;"> &amp;&amp;</span><span style="color:#E1E4E8;"> c[</span><span style="color:#9ECBFF;">&quot;status&quot;</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">==</span><span style="color:#9ECBFF;"> &quot;True&quot;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">            return</span><span style="color:#79B8FF;"> true</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#F97583;">    return</span><span style="color:#79B8FF;"> false</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>But not all CRs follow this convention.</p><h3 id="practical-approach-combined-strategy" tabindex="-1">Practical Approach: Combined Strategy <a class="header-anchor" href="#practical-approach-combined-strategy" aria-label="Permalink to &quot;Practical Approach: Combined Strategy&quot;">​</a></h3><p>In practice, we&#39;ll likely need to combine multiple strategies:</p><ol><li>Default: Check Conditions convention (type=Ready)</li><li>Fallback: Time-based safety with minDelay</li><li>Override: User-defined readyProbe for custom logic</li></ol><div class="language-yaml line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#85E89D;">spec</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#85E89D;">  rollout</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#85E89D;">    maxSkew</span><span style="color:#E1E4E8;">: </span><span style="color:#79B8FF;">10</span></span>
<span class="line"><span style="color:#85E89D;">    minDelay</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">30s</span><span style="color:#6A737D;">  # Fallback: Minimum wait when Ready detection fails</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>If you have good ideas for this problem, please share them on <a href="https://github.com/k8s-lynq/lynq/issues" target="_blank" rel="noreferrer">GitHub Issues</a>.</p><h2 id="conclusion" tabindex="-1">Conclusion <a class="header-anchor" href="#conclusion" aria-label="Permalink to &quot;Conclusion&quot;">​</a></h2><p>Implementing maxSkew seemed simple but hid unexpected complexity. To answer &quot;how many nodes are currently updating?&quot;, we had to dig deep into race conditions from StatusManager&#39;s batch processing, Deployment rollout states, and the multi-layered definition of Ready.</p><p>And there&#39;s still the unresolved challenge of Custom Resource Ready detection. Due to non-standardized status representations, there&#39;s no perfect solution, but a practical approach combining time-based safety measures and user-defined probes should be viable.</p><p>The most important lesson from this experience: <strong>Performance optimization (batch processing) creates new complexity (race conditions), and &quot;Ready&quot; is defined differently depending on context.</strong> Always keep these two things in mind.</p><hr><p>The <code>maxSkew</code> feature is available starting from <strong>Lynq v1.1.16</strong>. For more details, see the <a href="/configuration.html#rollout-configuration">rollout configuration documentation</a>.</p>`,55)),n(y)])}const A=E(m,[["render",h]]);export{S as __pageData,A as default};
